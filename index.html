
<!doctype html>

<html>
<head>
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="theme-color" content="#4F7DC9">
  <meta charset="UTF-8">
  <title>Build an AI-Powered Quiz App with Gemini and Firebase</title>
  <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Source+Code+Pro:400|Roboto:400,300,400italic,500,700|Roboto+Mono">
  <link rel="stylesheet" href="//fonts.googleapis.com/icon?family=Material+Icons">
  <link rel="stylesheet" href="https://storage.googleapis.com/claat-public/codelab-elements.css">
  <style>
    .success {
      color: #1e8e3e;
    }
    .error {
      color: red;
    }
  </style>
</head>
<body>
  <google-codelab-analytics gaid="UA-49880327-14" ga4id=""></google-codelab-analytics>
  <google-codelab codelab-gaid=""
                  codelab-ga4id=""
                  id="integrate-gemini-with-android"
                  title="Build an AI-Powered Quiz App with Gemini and Firebase"
                  environment="web"
                  feedback-link="https://github.com/google/generative-ai-docs/issues">
    
      <google-codelab-step label="Overview" duration="5">
        <h2 is-upgraded>About this codelab</h2>
<p><strong>Author:</strong> Carlos Mota<br><strong>Source: </strong><a href="https://github.com/cmota/QuizSpark" target="_blank">GitHub Repository</a><br><strong>Feedback: </strong><a href="https://github.com/cmota/QuizSpark/issues" target="_blank">Submit Issues</a><br><strong>Last Updated:</strong> November 21, 2025</p>
<p>In this Codelab, you&#39;ll build <strong>Quiz Spark</strong>, a fully functional Android application that uses Gemini to generate quizzes on any topic a user enters. You&#39;ll use <strong>Firebase AI Logic</strong> to create the questionsa and <strong>Firebase Firestore</strong> to store and display a live leaderboard.</p>
<p>This Codelab is designed for those who have some basic experience with Android development but are new to generative AI with Gemini or backend services with Firebase. We&#39;ll explain every concept step-by-step.</p>
<h2 is-upgraded>What you&#39;ll build</h2>
<p>You&#39;ll build a complete Android app with three main screens:</p>
<ul>
<li><strong>Intro Screen</strong>: A screen where the user can enter any topic (e.g., &#34;Roman History,&#34; &#34;Kotlin Programming,&#34; &#34;Marine Biology&#34;).</li>
<li><strong>Quiz Screen</strong>: A screen that displays 10 multiple-choice questions about the chosen topic, generated in real-time by Gemini.</li>
<li><strong>Leaderboard Screen</strong>: A screen that shows the highest scores, saved to and read from a live Firebase Firestore database.</li>
</ul>
<p class="image-container"><img alt="Design Mockups of Quiz Spark generated by Google&amp;rsquo;s Stitch project." src="img/1c510c76c0c0b3ac.png"></p>
<p><strong>Note:</strong> These screens were generated using <a href="https://stitch.withgoogle.com/" target="_blank">Google Stitch</a> - an AI-powered design tool from Google that transforms text prompts, sketches, or screenshots into user interface (UI) designs for web and mobile apps.</p>
<h2 class="checklist" is-upgraded>What You&#39;ll Learn</h2>
<ul class="checklist">
<li>How to integrate the <strong>Firebase Logic AI</strong> into an Android app.</li>
<li>How to configure your Gemini calls to get structured, reliable output.</li>
<li>How to use <strong>Firebase Firestore</strong> to save and retrieve data in real-time.</li>
<li>How to structure a modern Android app using <strong>Jetpack Compose and ViewModels.</strong></li>
<li>How to build a clean, multi-screen navigation flow in Compose.</li>
</ul>
<h2 is-upgraded>What you&#39;ll need</h2>
<ul>
<li>The latest version of <a href="https://developer.android.com/studio" target="_blank">Android Studio</a>.</li>
<li>A <a href="https://firebase.google.com/docs/android/setup" target="_blank">Firebase project</a>.</li>
<li>Basic knowledge of the Kotlin programming language.</li>
<li>An Android device or emulator.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Check out the code" duration="5">
        <p>Start by checking out the <strong>starter project</strong> source code from GitHub:</p>
<pre><code language="language-bash" class="language-bash">git clone -b starter https://github.com/cmota/QuizSpark.git
</code></pre>
<p>The <code>starter</code> key that you see on the command, is to checkout the <strong>starter</strong> branch of the project.</p>
<p>You can directly access the final implementation of the source code by checking out the <strong>main</strong> branch:</p>
<pre><code language="language-bash" class="language-bash">git switch main
</code></pre>
<p>Or remove the <code>-b</code> option from the <code>git clone</code> command:</p>
<pre><code language="language-bash" class="language-bash">git clone https://github.com/cmota/QuizSpark.git
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Setup Your Firebase Project" duration="10">
        <p>Before we start coding, we need to set up our Firebase backend. QuizSpark uses two Firebase services:</p>
<ul>
<li><strong>Firebase AI Logic (Gemini)</strong>: To generate the quiz questions.</li>
<li><strong>Firebase Firestore:</strong> To save and load the leaderboard scores.</li>
</ul>
<h2 is-upgraded>Create a Firebase Project</h2>
<ol type="1">
<li>Go to the <a href="https://console.firebase.google.com/" target="_blank">Firebase console</a>.</li>
<li>Click <strong>Create a new Firebase project</strong> and follow the on-screen instructions to create a new project. Give it a name like &#34;QuizSpark&#34;.</li>
</ol>
<p>Once everything is set click on <strong>continue</strong> to open your new Firebase project configuration screen.</p>
<h2 is-upgraded>Add Firebase to your Android App</h2>
<p>In your new project&#39;s <strong>Project Overview</strong>, click on <strong>+ Add app</strong> and then select the <strong>Android</strong> icon to launch the setup wizard.</p>
<p>Enter your application&#39;s package name. You can find this in your <code>app/build.gradle.kts</code> file (it&#39;s <code>com.cmota.quizspark</code> for this project).</p>
<p>Although it&#39;s option, you can also add the app nickname, which is useful when you have several apps on your project, to easily identify them.</p>
<p>Download the <code>google-services.json</code> file and place it in your app&#39;s module (app-level) directory (usually <code>app/</code>).</p>
<p>The Firebase wizard&#39;s shows you the instructions to add the Firebase SDKs (Bill of Materials) to your <code>build.gradle.kts</code> files.</p>
<p>On your starter project you already have all the plugins and libraries that you&#39;re going to use set, so you can skip these steps.</p>
<p><strong>Note:</strong> This project uses Gradle&#39;s version catalog. This means that the project plugins and libraries, along its versions are defined on <code>gradle/libs.versions.toml</code>. Although, this was created for a multi-module project to handle all the versions under the same file, it&#39;s a recommended practice for every project.</p>
<h2 is-upgraded>Enable Required Services</h2>
<h3 is-upgraded>Enable Firebase AI Logic</h3>
<ol type="1">
<li>In the Firebase console, navigate to <strong>AI</strong> in the left-hand menu.</li>
<li>Click <strong>Get started</strong>.</li>
<li>Select <strong>Get started with this API</strong> under the <strong>Gemini Developer API</strong> card.</li>
<li>Follow the prompts on the screen to enable this API.</li>
</ol>
<p><strong>Note:</strong> The dependencies are already added to the project, so you can skip this step.</p>
<h3 is-upgraded>Enable Firebase Firestore</h3>
<ol type="1">
<li>In the Firebase console, go to <strong>Build &gt; Firestore Database</strong>.</li>
<li>Click <strong>Create database</strong>.</li>
<li>Select <strong>Standard Edition</strong> since you&#39;re not going to store a lot of information on the database.</li>
<li>Start in <strong>Test mode</strong>. This allows us to read and write to the database without complex authentication rules. For a production app, you should set up more secure rules.</li>
</ol>
<p><strong>Note:</strong> The dependencies are already added to the project, so you can skip this step.</p>
<h2 is-upgraded>Dependencies</h2>
<p>Open your <code>app/build.gradle.kts</code> file. You can see the Firebase dependencies added:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">// Firebase Bill of Materials (BoM)
implementation(platform(libs.firebase.bom))

// Firebase AI (for Gemini)
implementation(libs.firebase.ai)

// Firebase Firestore (for Leaderboard)
implementation(libs.firebase.firestore)
</code></pre>
<p>They&#39;re defined in <code>gradle/libs.versions.toml</code>:</p>
<pre><code language="language-toml" class="language-toml"># Firebase Bill of Materials (BoM)
firebase-bom = { module = &#34;com.google.firebase:firebase-bom&#34;, version.ref = &#34;firebaseBom&#34; }

# Firebase AI (for Gemini)
firebase-ai = { module = &#34;com.google.firebase:firebase-ai&#34; }

# Firebase Firestore (for Leaderboard)
firebase-firestore = { module = &#34;com.google.firebase:firebase-firestore&#34; }
</code></pre>
<p>With the backend ready, let&#39;s start building the app!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Define the Data Models" duration="5">
        <p>A good app starts with a clear data structure. We have two main data models: <code>Question</code> and <code>User</code>.</p>
<h2 is-upgraded>Question Model</h2>
<p>This defines the structure for a single quiz question. We&#39;ll tell the Gemini API to provide its response in this exact format. The <code>@Serializable</code> annotation is from the <a href="https://github.com/Kotlin/kotlinx.serialization" target="_blank">Kotlinx Serialization</a> library, which will help us parse the JSON response from Gemini easily.</p>
<p>Create the file <code>java/com/cmota/quizspark/model/Question.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark.model

import kotlinx.serialization.Serializable

@Serializable
data class Question(
  val question: String = &#34;&#34;,
  val options: List&lt;String&gt; = emptyList(),
  val correct: Int = 0
)
</code></pre>
<h2 is-upgraded>User Model</h2>
<p>This defines the data we&#39;ll store in our Firestore leaderboard for each user. <code>@DocumentId</code> tells Firestore to automatically populate the `uid field with the document&#39;s unique ID.</p>
<p>This file is already created and located in <code>java/com/cmota/quizspark/model/User.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark.model

import com.google.firebase.firestore.DocumentId

data class User(
  @DocumentId val uid: String? = null,
  val username: String = &#34;&#34;,
  val score: Long = 0L
)
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Set Up App Theme and Navigation" duration="10">
        <p>Before building screens, let&#39;s set up our app&#39;s visual style (Theme) and how we move between screens (Navigation).</p>
<h2 is-upgraded>Theme</h2>
<p>Our theme files define the app&#39;s look and feel, including colors and typography. This project uses a dark, &#34;spark&#34; theme.</p>
<ul>
<li><code>java/com/cmota/quizspark/ui/theme/Color.kt</code><br> Defines our custom colors like <code>darkGreenBackground</code> and <code>brightGreen</code>.</li>
<li><code>java/com.cmota/quizspark/ui/theme/Type.kt</code><br> Sets up the font styles.</li>
<li><code>java/com/cmota/quizspark/ui/theme/Theme.kt</code><br> Brings it all together in a <code>QuizSparkTheme</code> composable, which wraps our entire application.</li>
</ul>
<h2 is-upgraded>Navigation</h2>
<p>The app uses <a href="https://developer.android.com/guide/navigation/navigation-3" target="_blank">Navigation 3</a>.</p>
<ul>
<li><strong>Navigation Routes</strong>: First, we define our screens (routes) as serializable objects. This is a clean, type-safe way to manage navigation.</li>
</ul>
<p>Create <code>java/com/cmota/quizspark/ui/navigation/NavigationRoutes.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark.ui.navigation

import androidx.navigation3.runtime.NavKey
import kotlinx.serialization.Serializable

@Serializable
data object Intro: NavKey

@Serializable
data object Quiz: NavKey

@Serializable
data object Leaderboard: NavKey
</code></pre>
<p>Each one of this <code>data</code> objects correspond to an app screen.</p>
<ul>
<li><strong>Main Navigation Graph</strong>: This file, <code>MainNavigation.kt</code>, is the app&#39;s &#34;scaffolding.&#34; It defines which screen is shown and how to transition between them. It also initializes and passes our <code>ViewModels</code> to the correct screens.</li>
</ul>
<p>Update the existing file - <code>java/com/cmota/quizspark/ui/navigation/MainNavigation.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark.ui.navigation

import androidx.compose.runtime.Composable
import androidx.navigation3.runtime.entryProvider
import androidx.navigation3.runtime.rememberNavBackStack
import androidx.navigation3.ui.NavDisplay
import com.cmota.quizspark.ui.leaderboard.LeaderboardViewModel
import com.cmota.quizspark.ui.questions.QuestionsViewModel
import com.cmota.quizspark.ui.screens.IntroScreen
import com.cmota.quizspark.ui.screens.LeaderboardScreen
import com.cmota.quizspark.ui.screens.QuizScreen

@Composable
fun MainNavigation(
  questionsViewModel: QuestionsViewModel,
  leaderboardViewModel: LeaderboardViewModel
) {
  // Start the app with the Intro screen
  val backStack = rememberNavBackStack(Intro)

  NavDisplay(
    backStack = backStack,
    onBack = { backStack.removeLastOrNull() },
    entryProvider = entryProvider {
      
      entry&lt;Intro&gt; {
        // Your Intro screen will be called here
      }

      entry&lt;Quiz&gt; {
        // Your Quiz screen will be called here
      }

      entry&lt;Leaderboard&gt; {
        // Your Leaderboard screen will be called here
      }
    }
  )
}
</code></pre>
<p>Because there are no screens built yet, the <code>content</code> of each <code>entry</code> is empty. We will return to this file as we finish each screen.</p>
<ol type="1" start="3">
<li><strong>Main Activity</strong>: Finally, <code>MainActivity.kt</code> is the app&#39;s entry point. It sets up our <code>QuizSparkTheme</code> and calls <code>MainNavigation</code>, injecting our ViewModels.</li>
</ol>
<p>You can see this in <code>java/com/cmota/quizspark/MainActivity.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark

// ... imports
import androidx.activity.viewModels
import com.cmota.quizspark.ui.leaderboard.LeaderboardViewModel
import com.cmota.quizspark.ui.navigation.MainNavigation
import com.cmota.quizspark.ui.questions.QuestionsViewModel
import com.cmota.quizspark.ui.theme.QuizSparkTheme

class MainActivity : ComponentActivity() {

  private val questionsViewModel: QuestionsViewModel by viewModels()
  private val leaderboardViewModel: LeaderboardViewModel by viewModels()

  override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    enableEdgeToEdge()
    setContent {
      QuizSparkTheme {
        MainNavigation(
          questionsViewModel = questionsViewModel,
          leaderboardViewModel = leaderboardViewModel
        )
      }
    }
  }
}
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Build the Intro Screen" duration="15">
        <p>This is our simplest screen. It&#39;s composed of a text field and a button.</p>
<p>Create <code>java/com/cmota/quizspark/ui/screens/IntroScreen.kt</code>.</p>
<p><strong>Note:</strong> You also need to create the <strong>screens</strong> folder. You can easily do that, by selecting the <code>ui</code> folder and <strong>right click</strong> on it, followed by <strong>New</strong> &gt; <strong>Package</strong>.</p>
<p>The UI is built with standard Jetpack Compose composables like <code>Column</code>, <code>Text</code>, <code>OutlinedTextField</code>, and <code>Button</code>.</p>
<p class="image-container"><img style="width: 250.00px" src="img/aa72eaed328cbc6c.png"></p>
<p>This screen needs to do two things: present a clean title bar and provide a form for the user to enter their quiz topic.</p>
<p>Paste the code above into your file, and let&#39;s walk through what&#39;s happening, starting from the outside and working our way in.</p>
<pre><code language="language-kotlin" class="language-kotlin">@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun IntroScreen(
  navigateToQuiz: (String) -&gt; Unit
) {
  Scaffold(
    topBar = {
      CenterAlignedTopAppBar(
        title = {
          Text(
            text = stringResource(R.string.app_name)
          )
        }
      )
    }
  ) { innerPadding -&gt;
    IntroContent(
      modifier = Modifier.padding(innerPadding),
      navigateToQuiz = navigateToQuiz
    )
  }
}
</code></pre>
<p>This is your public entry point. It accepts a lambda function, <code>navigateToQuiz</code>, which takes a <code>String</code>. This is how we will pass the user&#39;s chosen topic to the next screen later on.</p>
<p>We use a <code>Scaffold</code> to set up the standard Material Design layout:</p>
<ul>
<li><code>topBar</code>: We use a <code>CenterAlignedTopAppBar</code> to display the app&#39;s name.</li>
</ul>
<p><strong>Note:</strong> You&#39;ll see <code>@OptIn(ExperimentalMaterial3Api::class)</code> at the top. This is currently required because the Material 3 TopAppBar API is still technically experimental, though stable enough for us to use!</p>
<ul>
<li><code>innerPadding</code>: The Scaffold provides this padding to ensure your content doesn&#39;t get hidden behind the top bar or system status bars. We pass this directly to our content composable.</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
private fun IntroContent(
  modifier: Modifier,
  navigateToQuiz: (String) -&gt; Unit
) {
  Column(
    modifier = modifier
      .fillMaxSize()
      .padding(16.dp),
    verticalArrangement = Arrangement.Center
  ) {

    Column(
      modifier = Modifier.fillMaxWidth(),
      horizontalAlignment = Alignment.CenterHorizontally
    ) {
      Text(
        text = stringResource(R.string.intro_create_your_challenge),
        style = MaterialTheme.typography.displayMedium
      )

      Spacer(modifier = Modifier.height(16.dp))

      Text(
        text = stringResource(R.string.intro_create_your_challenge_hint),
        style = MaterialTheme.typography.titleLarge
      )
    }

    Spacer(modifier = Modifier.height(64.dp))

    Text(
      text = stringResource(R.string.intro_topic)
    )

    Spacer(modifier = Modifier.height(8.dp))

    val topic = remember { mutableStateOf(&#34;&#34;) }

    OutlinedTextField(
      value = topic.value,
      onValueChange = { topic.value = it },
      modifier = Modifier.fillMaxWidth(),
      placeholder = {
        Text(
          text = stringResource(R.string.intro_topic_hint)
        )
      },
      shape = RoundedCornerShape(50),
      singleLine = true
    )

    Spacer(modifier = Modifier.height(16.dp))

    Row {
      Icon(
        painter = painterResource(R.drawable.ic_generated),
        stringResource(R.string.description_generated)
      )

      Spacer(modifier = Modifier.width(8.dp))

      Text(
        text = stringResource(R.string.intro_ai_info)
      )
    }

    Spacer(modifier = Modifier.height(64.dp))

    Button(
      onClick = { navigateToQuiz(topic.value) },
      modifier = Modifier.fillMaxWidth(),
      shape = RoundedCornerShape(50),
      enabled = topic.value.isNotEmpty()
    ) {
      Text(
        text = stringResource(R.string.intro_start),
        style = MaterialTheme.typography.titleLarge,
        modifier = Modifier.padding(top = 8.dp, bottom = 8.dp),
        fontWeight = FontWeight.Bold
      )
    }
  }
}
</code></pre>
<p>This is where the heavy lifting happens.</p>
<p>We use a root <code>Column</code> to stack elements vertically. By using <code>Arrangement.Center</code>, we ensure the form sits comfortably in the middle of the screen rather than bunching up at the top.</p>
<p>Inside this column, we have three main sections:</p>
<ol type="1">
<li><strong>The Header:</strong> We nest a second Column here to group the title and the subtitle.<ul>
<li><strong>The Title</strong> uses <code>displayMedium</code> for large, bold text.</li>
<li><strong>The Subtitle</strong> uses <code>titleLarge</code> to provide a hint to the user.</li>
<li>We use <code>Spacer</code> elements throughout the layout. These are invisible blocks that add breathing room between your widgets, preventing the UI from looking cluttered.</li>
</ul>
</li>
<li><strong>The Input Field:</strong> This is the most interactive part of the screen.</li>
</ol>
<pre><code language="language-kotlin" class="language-kotlin">val topic = remember { mutableStateOf(&#34;&#34;) }

OutlinedTextField(
  value = topic.value,
  onValueChange = { topic.value = it },
  ...
)
</code></pre>
<ul>
<li><code>topic</code>: We use <code>remember { mutableStateOf("") }</code> to hold the text the user types. Because this is a State object, any time <code>topic.value</code> changes, Compose will automatically redraw the text field to show the new letter.</li>
<li><code>OutlinedTextField</code>: This is the standard Material input box. We give it a <code>RoundedCornerShape(50)</code> to make it pill-shaped and set `singleLine = true so the keyboard shows a &#34;Done&#34; or &#34;Next&#34; action instead of a new line.</li>
</ul>
<ol type="1" start="3">
<li><strong>The Action Button:</strong> Finally, we have the &#34;Start&#34; button at the bottom.</li>
</ol>
<pre><code language="language-kotlin" class="language-kotlin">Button(
  onClick = { navigateToQuiz(topic.value) },
  enabled = topic.value.isNotEmpty(),
  ...
)
</code></pre>
<ul>
<li><code>enabled</code>: The button is disabled (greyed out) as long as the topic text is empty. The user can&#39;t proceed until they type something.</li>
<li><code>onClick</code>: When clicked, we trigger the <code>MapsToQuiz</code> callback we passed down from the top, sending the `topic.value along with it.</li>
</ul>


      </google-codelab-step>
    
      <google-codelab-step label="Generate Quizzes with Gemini" duration="15">
        <p>This is the heart of the application. We&#39;ll use a ViewModel to handle the logic of calling the Gemini API and parsing its response.</p>
<h2 is-upgraded>UI State</h2>
<p>First, we need a way to represent the different states of this request: Is it loading? Did it succeed? Did it fail? A sealed interface is perfect for this.</p>
<p>Create <code>java/com/cmota/quizspark/ui/questions/UiState.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark.ui.questions

import com.cmota.quizspark.model.Question

sealed interface UiState {
  data object Initial : UiState
  data object Loading : UiState
  data class Success(val questions: List&lt;Question&gt;) : UiState
  data class Error(val message: String) : UiState
}
</code></pre>
<h2 is-upgraded>Questions ViewModel</h2>
<p>This is where the magic happens. This class is responsible for all the logic related to the quiz.</p>
<p>Open <code>java/com/cmota/quizspark/ui/questions/QuestionsViewModel.kt</code>.</p>
<p>Before the class declaration you can see this constant defined:</p>
<pre><code language="language-kotlin" class="language-kotlin">private const val QUESTIONS = 10
</code></pre>
<p>This is going to used later one, and it&#39;s this value that defines the number of questions to be generated.</p>
<p>Let&#39;s break it down.</p>
<h3 is-upgraded>System Instruction</h3>
<p>This is a <em>critical</em> concept. We give the Gemini API a &#34;system instruction&#34; that tells it how to behave. We instruct it to be a quiz assistant and, most importantly, to only respond with a valid JSON array matching our `Question data model.</p>
<p>Inside the class declaration add:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">private val systemInstruction = &#34;&#34;&#34;
    You are a quiz generation assistant.
    Your response MUST be a single, valid JSON array.
    The array must contain exactly $QUESTIONS JSON objects.
    Do not add any other text, explanation, or markdown formatting around the JSON.

    Each JSON object in the array must match this exact structure:
    {
      &#34;question&#34;: &#34;The question text as a string.&#34;,
      &#34;options&#34;: &#34;A list of 4 strings for the answers.&#34;,
      &#34;correct&#34;: &#34;The 0-based index (integer) of the correct answer.&#34;
    }
    &#34;&#34;&#34;
</code></pre>
<h3 is-upgraded>Model Initialization</h3>
<p>Now, it&#39;s time to initialize the <code>generativeModel</code>:</p>
<ul>
<li><code>Firebase.ai(backend = GenerativeBackend.googleAI())</code> to get the service.</li>
<li><code>modelName</code> indicates which model you&#39;re going to use</li>
<li><code>generationConfig</code> along with the <code>systemInstruction</code> that you&#39;ve defined previously, enables <strong>JSON mode</strong>, ensuring the API&#39;s output is only the JSON we asked for.</li>
</ul>
<pre><code language="language-Kotlin" class="language-Kotlin">private val generationConfig = generationConfig {
    responseMimeType = &#34;application/json&#34;
}

private val generativeModel by lazy {
    Firebase.ai(backend = GenerativeBackend.googleAI())
      .generativeModel(
        modelName = &#34;gemini-2.5-flash-lite&#34;,
        generationConfig = generationConfig,
        systemInstruction = content {
          text(systemInstruction)
        }
      )
}
</code></pre>
<p><strong>Note:</strong> You need to import <code>content</code> from <code>import com.google.firebase.ai.type.content</code>.</p>
<p>After everything is set, define the JSON parser, so you can deserialize the response.</p>
<pre><code language="language-kotlin" class="language-kotlin">private val jsonParser = Json { ignoreUnknownKeys = true }
</code></pre>
<h2 is-upgraded>Generating the Quiz</h2>
<p>Start by declaring these properties:</p>
<pre><code language="language-kotlin" class="language-kotlin">private val _question = MutableStateFlow(Question())
val question: StateFlow&lt;Question&gt; = _question.asStateFlow()

private val _questions = MutableStateFlow&lt;UiState&gt;(UiState.Initial)
val questions: StateFlow&lt;UiState&gt; = _questions.asStateFlow()

private val _indexCurrent = MutableStateFlow(0)
val indexCurrent: StateFlow&lt;Int&gt; = _indexCurrent.asStateFlow()

private val _indexLast = MutableStateFlow(QUESTIONS)
val indexLast: StateFlow&lt;Int&gt; = _indexLast.asStateFlow()

private val answered = mutableListOf&lt;Int&gt;()
</code></pre>
<p>They&#39;re going to be responsible to notify the UI with new content:</p>
<ul>
<li><code>question</code>: hold the current question</li>
<li><code>questions</code>: defines the state of the request and contains all the questions in case it&#39;s <code>Success</code></li>
<li><code>indexCurrent</code>: the number of the current question</li>
<li><code>indexLast</code>: the total number of questions</li>
<li><code>answered</code>: the user answers.</li>
</ul>
<p>Now, add <code>generateQuiz</code> function:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">fun generateQuiz(topic: String) {
  viewModelScope.launch {
    try {
      answered.clear()
      _questions.value = UiState.Loading

      val prompt = &#34;Generate $QUESTIONS question about $topic.&#34;

      val response = generativeModel.generateContent(prompt)
      val questions = jsonParser.decodeFromString&lt;List&lt;Question&gt;&gt;(response.text ?: &#34;&#34;)

      _question.value = questions.first()
      _questions.value = UiState.Success(questions)

      _indexLast.value = questions.size
      _indexCurrent.value = 1

    } catch (e: Exception) {
      Log.d(TAG, &#34;Error: ${e.message}&#34;)
      _questions.value = UiState.Error(e.message ?: &#34;An unknown error occurred&#34;)
    }
  }
}
</code></pre>
<p>Here&#39;s a break down of it&#39;s logic:</p>
<ul>
<li>It sets the state to <code>Loading</code>.</li>
<li>It creates a simple prompt, like &#34;Generate 10 questions about Roman History.&#34;</li>
<li>It calls <code>generativeModel.generateContent(prompt)</code>.</li>
<li>Because we set up JSON mode, the <code>response.text</code> will be a clean JSON string.</li>
<li>We use <code>jsonParser.decodeFromString</code> to turn that string into a <code>List<Question></code>.</li>
<li>We update the state to <code>Success</code>, passing in the list of questions.</li>
</ul>
<h3 is-upgraded>Helper Functions</h3>
<p>The <code>answerQuestion</code> and <code>score</code> functions handle the quiz logic, like moving to the next question and counting the correct answers at the end.</p>
<pre><code language="language-kotlin" class="language-kotlin">fun answerQuestion(answer: Int) {
  val data = _questions.value
  if (data !is UiState.Success) {
    return
  }

  answered.add(answer)
  if (answered.size &lt; data.questions.size) {
    _question.value = data.questions[answered.size]
    _indexCurrent.value = answered.size + 1
  }
}

fun score(): Int {
  val data = _questions.value
  if (data !is UiState.Success) {
    return 0
  }

  return answered.zip(data.questions)
    .count { (answer, question) -&gt;
      answer == question.correct
    }
}
</code></pre>
<p>Now that everything is set, return to <code>MainNavigation.kt</code> and inside <code>entry<Intro></code> add:</p>
<pre><code language="language-kotlin" class="language-kotlin">IntroScreen(
  navigateToQuiz = { topic -&gt;
    backStack.add(Quiz)
    questionsViewModel.generateQuiz(topic)
  }
)
</code></pre>
<p>Compile and run the app to confirm that everything is working.</p>


      </google-codelab-step>
    
      <google-codelab-step label="Build the Quiz Screen" duration="15">
        <p>Now that our <code>QuestionsViewModel</code> can generate quizzes, let&#39;s build the UI to display them.</p>
<p class="image-container"><img style="width: 250.00px" src="img/1341a605433fc5a1.png"></p>
<p>Create <code>java/com/cmota/quizspark/ui/screens/QuizScreen.kt</code> and add the following code:</p>
<pre><code language="language-kotlin" class="language-kotlin">@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun QuizScreen(
  questionsViewModel: QuestionsViewModel,
  leaderboardViewModel: LeaderboardViewModel,
  navigateToHome: () -&gt; Unit,
  navigateToLeaderboard: () -&gt; Unit
) {

  val question = questionsViewModel.question.collectAsState()
  val questions = questionsViewModel.questions.collectAsState()

  val indexLast = questionsViewModel.indexLast.collectAsState()
  val indexCurrent = questionsViewModel.indexCurrent.collectAsState()

  val selectedOption = remember { mutableStateOf&lt;Int?&gt;(null) }
  val showUsernameDialog = remember { mutableStateOf(false) }

  Scaffold(
    topBar = {
      CenterAlignedTopAppBar(
        title = {
          Text(
            text = stringResource(R.string.quiz_question, indexCurrent.value, indexLast.value)
          )
        },
        navigationIcon = {
          IconButton(
            onClick = { navigateToHome() }
          ) {
            Icon(
              imageVector = Icons.Default.Close,
              contentDescription = stringResource(R.string.description_close_quiz)
            )
          }
        }
      )
    },
    bottomBar = {
      if (indexCurrent.value == indexLast.value) {
        QuizBottomAction(
          actionResId = R.string.quiz_submit,
          enabled = questions.value is UiState.Success &amp;&amp; selectedOption.value != null,
          onClick = { showUsernameDialog.value = true }
        )
      } else {
        QuizBottomAction(
          actionResId = R.string.quiz_next,
          enabled = questions.value is UiState.Success &amp;&amp; selectedOption.value != null,
          onClick = { selectedOption.value?.let {
            questionsViewModel.answerQuestion(it)
            selectedOption.value = null
          }}
        )
      }
    }
  ) { innerPadding -&gt;
    QuizContent(
      modifier = Modifier.padding(innerPadding),
      question = question.value,
      questions = questions.value,
      selectedOption = selectedOption
    )

    if (showUsernameDialog.value) {
      UsernameDialog(
        confirmAction = { username -&gt;
          val score = questionsViewModel.score()
          leaderboardViewModel.savePoints(username, score)
          showUsernameDialog.value = false
          navigateToLeaderboard()
        },
        dismissAction = { showUsernameDialog.value = false }
      )
    }
  }
}
</code></pre>
<h2 is-upgraded>State Management &amp; Skeleton</h2>
<p>In <code>QuizScreen</code>, we start by collecting all the data we need from our ViewModels.</p>
<pre><code language="language-kotlin" class="language-kotlin">val question = questionsViewModel.question.collectAsState()
val indexCurrent = questionsViewModel.indexCurrent.collectAsState()
// ...
val selectedOption = remember { mutableStateOf&lt;Int?&gt;(null) }
</code></pre>
<ul>
<li><code>collectAsState</code>: We listen to the <code>QuestionsViewModel</code> for the current question text and our progress (e.g., &#34;Question 1 of 5&#34;).</li>
<li><code>selectedOption</code>: This is a local UI state. We need to know which button the user just tapped so we can highlight it before they hit &#34;Next.&#34;</li>
</ul>
<p><strong>Note:</strong> Compose will automatically &#34;recompose&#34; (re-draw) the UI whenever this state changes.</p>
<h2 is-upgraded>Dynamic Bottom Bar</h2>
<p>The logic for moving through the quiz lives in the Scaffold&#39;s <code>bottomBar</code></p>
<pre><code language="language-kotlin" class="language-kotlin">if (indexCurrent.value == indexLast.value) {
  // We are at the end! Show &#34;Submit&#34;
  QuizBottomAction(..., onClick = { showUsernameDialog.value = true })
} else {
  // We are in the middle. Show &#34;Next&#34;
  QuizBottomAction(..., onClick = {
    questionsViewModel.answerQuestion(selectedOption.value!!)
    selectedOption.value = null // Reset selection for the next page
  })
}
</code></pre>
<ul>
<li>Logic: We compare the current index to the last index.</li>
<li>UX: Note the enabled property. We prevent the user from clicking &#34;Next&#34; or &#34;Submit&#34; until <code>selectedOption</code> is not null. This prevents them from accidentally skipping a question.</li>
</ul>
<p>Next, you&#39;re going to show the correct screen depending if the questions were fetched successfully or not:</p>
<ul>
<li><code>Initial</code> / <code>Loading</code>: Show a <code>QuizContentLoading</code> composable (a progress bar).</li>
<li><code>Success</code>: Show the <code>QuizContentSuccess</code> composable with the actual question.</li>
<li><code>Error</code>: Show a <code>QuizContentError</code> message.</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
private fun QuizContent(
  modifier: Modifier,
  question: Question,
  questions: UiState,
  selectedOption: MutableState&lt;Int?&gt;
) {
  Column(
    modifier = modifier
      .fillMaxSize()
      .padding(16.dp),
    horizontalAlignment = Alignment.CenterHorizontally
  ) {

    when(questions) {
      is UiState.Initial,
      is UiState.Loading -&gt; QuizContentLoading()
      is UiState.Success -&gt; QuizContentSuccess(
          question = question,
          selectedOption = selectedOption
      )
      is UiState.Error -&gt; QuizContentError()
    }
  }
}
</code></pre>
<p>Compose will automatically &#34;recompose&#34; (re-draw) the UI whenever this state changes.</p>
<h2 is-upgraded>Rendering Quiz Options</h2>
<p>Here we loop through the options and create a <code>QuizOption</code> for each one.</p>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
private fun QuizContentSuccess(
  question: Question,
  selectedOption: MutableState&lt;Int?&gt;
) {
  Spacer(modifier = Modifier.height(32.dp))

  Text(
    text = question.question,
    style = MaterialTheme.typography.displayMedium
  )

  Spacer(modifier = Modifier.height(32.dp))

  question.options.forEachIndexed { index, option -&gt;
    QuizOption(
      id = index,
      option = option,
      isSelected = selectedOption.value == index,
      onOptionSelected = { selectedOption.value = it }
    )

    Spacer(modifier = Modifier.height(16.dp))
  }
}
</code></pre>
<p>The <code>QuizOption</code> composable handles its own styling based depending if it&#39;s selected or not:</p>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
private fun QuizOption(
  id: Int,
  option: String,
  isSelected: Boolean,
  onOptionSelected: (Int) -&gt; Unit
) {
  Row(
    modifier = Modifier
      .fillMaxWidth()
      .clip(RoundedCornerShape(50))
      .clickable(onClick = { onOptionSelected(id) })
      .background(MaterialTheme.colorScheme.secondary)
      .border(
        2.dp, if (isSelected) {
          MaterialTheme.colorScheme.primary
        } else {
          MaterialTheme.colorScheme.secondary
        }, RoundedCornerShape(50)
      )
      .padding(8.dp),
    verticalAlignment = Alignment.CenterVertically
  ) {

    Row(
      modifier = Modifier
        .size(45.dp)
        .background(
          if (isSelected) {
            MaterialTheme.colorScheme.primary
          } else {
            MaterialTheme.colorScheme.background
          }, shape = CircleShape
        ),
      horizontalArrangement = Arrangement.Center,
      verticalAlignment = Alignment.CenterVertically
    ) {
      Text(
        text = &#34;$id&#34;,
        style = MaterialTheme.typography.titleLarge
      )
    }

    Spacer(modifier = Modifier.width(16.dp))

    Text(
      text = option,
      style = MaterialTheme.typography.titleLarge
    )
  }
}

@Composable
private fun QuizContentLoading() {
  LinearProgressIndicator(
    modifier = Modifier.fillMaxWidth()
  )
}

@Composable
private fun QuizContentError() {
  Column(
    modifier = Modifier.fillMaxSize(),
    verticalArrangement = Arrangement.Center
  ) {
    Text(
      text = stringResource(R.string.quiz_error),
      style = MaterialTheme.typography.titleLarge
    )
  }
}

@Composable
private fun QuizBottomAction(
  @StringRes actionResId: Int,
  enabled: Boolean,
  onClick: () -&gt; Unit
) {
  Button(
    onClick = { onClick() },
    modifier = Modifier
      .fillMaxWidth()
      .padding(start = 16.dp, end = 16.dp, bottom = 32.dp),
    shape = RoundedCornerShape(50),
    enabled = enabled
  ) {
    Text(
      text = stringResource(actionResId),
      style = MaterialTheme.typography.titleLarge,
      modifier = Modifier.padding(top = 8.dp, bottom = 8.dp),
      fontWeight = FontWeight.Bold
    )
  }
}
</code></pre>
<h2 is-upgraded>Last Question</h2>
<p>When the user finishes the last question and clicks &#34;Submit,&#34; we set <code>showUsernameDialog.value = true</code>, which triggers the <code>UsernameDialog</code>:</p>
<ul>
<li>The user enters their name.</li>
<li><code>questionsViewModel.score()</code> to calculate their final result.</li>
<li><code>leaderboardViewModel.savePoints(...)</code> to writes that data into Firestore.</li>
<li>Finally, MapsToLeaderboard() whisks them away to see their ranking.</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
private fun UsernameDialog(
  confirmAction: (String) -&gt; Unit,
  dismissAction: () -&gt; Unit
) {
  val username = remember { mutableStateOf(&#34;&#34;) }

  AlertDialog(
    title = {
      Text(stringResource(R.string.quiz_dialog_submit_score))
    },
    text = {
      OutlinedTextField(
        value = username.value,
        onValueChange = { username.value = it },
        modifier = Modifier.fillMaxWidth(),
        placeholder = {
          Text(
            text = stringResource(R.string.quiz_dialog_username)
          )
        },
        shape = RoundedCornerShape(50),
        singleLine = true
      )
    },
    confirmButton = {
      TextButton(
        onClick = { confirmAction(username.value) },
        enabled = username.value.isNotEmpty()
      ) {
        Text(stringResource(R.string.quiz_dialog_submit_score))
      }
    },
    dismissButton = {
      TextButton(onClick = { dismissAction() }) {
        Text(stringResource(R.string.quiz_dialog_cancel))
      }
    },
    onDismissRequest = { dismissAction () }
  )
}
</code></pre>
<p>With this screen built, return to <code>MainNavigation.kt</code> and inside the <code>entry<QuizZ</code> add:</p>
<pre><code language="language-kotlin" class="language-kotlin">QuizScreen(
  questionsViewModel = questionsViewModel,
  leaderboardViewModel = leaderboardViewModel,
  navigateToHome = { backStack.remove(Quiz) },
  navigateToLeaderboard = { backStack.add(Leaderboard) }
)
</code></pre>
<p>Compile and run the project. You can now write a topic and you&#39;ll get 10 questions to answer - good luck!</p>


      </google-codelab-step>
    
      <google-codelab-step label="Save Scores to Firestore" duration="15">
        <p>When the user submits their score, we need to save it to our Firebase Firestore database. This logic lives in the <code>LeaderboardViewModel</code>.</p>
<h3 is-upgraded>Leaderboard UI State</h3>
<p>Just like with the quiz, we create a <code>UiState</code> for our leaderboard.</p>
<p>You can see it&#39;s declaration in <code>java/com/cmota/quizspark/ui/leaderboard/UiState.kt</code>:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">package com.cmota.quizspark.ui.leaderboard

import com.cmota.quizspark.model.User

sealed interface UiState {
  data object Initial : UiState
  data object Loading : UiState
  data class Success(val users: List&lt;User&gt;) : UiState
  data class Error(val message: String) : UiState
}
</code></pre>
<h3 is-upgraded>Leaderboard ViewModel</h3>
<p>Open <code>java/com/cmota/quizspark/ui/leaderboard/LeaderboardViewModel.kt</code>.</p>
<p>This ViewModel has two main jobs: saving points and fetching the leaderboard.</p>
<ol type="1">
<li><strong>Saving Points</strong>: The <code>savePoints</code> function is called from <code>QuizScreen</code> when the user submits their name from the dialog.</li>
</ol>
<ul>
<li>It calculates the score.</li>
<li>It creates a <code>mapOf</code> entry that matches our <code>User</code> model (username, score, and a server timestamp).</li>
<li>It uses <code>Firebase.firestore.collection("leaderboard").add(entry)</code> to add a new document to our &#34;leaderboard&#34; collection. Firestore handles the rest.</li>
</ul>
<p>Update the <code>savePoints</code> function to:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">fun savePoints(username: String, correct: Int) {
  val score = correct * 10
  val db = Firebase.firestore
  val entry = mapOf(
    &#34;username&#34; to username,
    &#34;score&#34; to score,
    &#34;timestamp&#34; to FieldValue.serverTimestamp()
  )

  db.collection(&#34;leaderboard&#34;).add(entry)
}
</code></pre>
<ol type="1" start="2">
<li><strong>Fetching Leaderboard</strong>: saves the current points and username into Firestore.</li>
</ol>
<ul>
<li>It sets the state to <code>Loading</code>.</li>
<li>It creates a query to get the &#34;leaderboard&#34; collection.</li>
<li>It orders the results by &#34;score&#34; in descending order (highest score first).</li>
<li>It calls <code>.get().await()</code> to fetch the data.</li>
<li>It uses the handy <code>.toObjects(User::class.java)</code> function to automatically convert the Firestore documents into our <code>User</code> data class.</li>
<li>It updates the state to <code>Success</code> with the list of users.</li>
</ul>
<pre><code language="language-Kotlin" class="language-Kotlin">fun fetchLeaderboard() {
  viewModelScope.launch {
    _leaderboard.value = UiState.Loading

    try {
      val query = Firebase.firestore
        .collection(&#34;leaderboard&#34;)
        .orderBy(&#34;score&#34;, Query.Direction.DESCENDING)

      val snapshot = query.get().await()

      val leaderboardList = snapshot.toObjects(User::class.java)

      _leaderboard.value = UiState.Success(leaderboardList)

    } catch (e: Exception) {
      Log.d(TAG, &#34;Error: ${e.message}&#34;)
      _leaderboard.value = UiState.Error(e.message ?: &#34;Unknown error&#34;)
    }
  }
}
</code></pre>
<p>Add the <code>_leaderboard</code> properties after the class declaration:</p>
<pre><code language="language-kotlin" class="language-kotlin">private val _leaderboard = MutableStateFlow&lt;UiState&gt;(UiState.Initial)
val leaderboard: StateFlow&lt;UiState&gt; = _leaderboard.asStateFlow()
</code></pre>


      </google-codelab-step>
    
      <google-codelab-step label="Build the Leaderboard Screen" duration="10">
        <p>Now that users can take the quiz, they need to see how they stack up against the competition! The <code>LeaderboardScreen</code> is very similar to the <code>QuizScreen</code> in that it just observes the <code>UiState</code> from its ViewModel.</p>
<p class="image-container"><img style="width: 250.00px" src="img/e46ea08d060f4dfb.png"></p>
<p>Create <code>java/com/cmota/quizspark/ui/screens/LeaderboardScreen.kt</code> and add the following composables:</p>
<pre><code language="language-Kotlin" class="language-Kotlin">@OptIn(ExperimentalMaterial3Api::class)
@Composable
fun LeaderboardScreen(
  leaderboardViewModel: LeaderboardViewModel,
  navigateToHome: () -&gt; Unit
) {

  val leaderboard = leaderboardViewModel.leaderboard.collectAsState()

  Scaffold(
    topBar = {
      CenterAlignedTopAppBar(
        title = {
          Text(
            text = stringResource(R.string.leaderboard)
          )
        },
      )
    },
    bottomBar = {
      Button(
        onClick = { navigateToHome() },
        modifier = Modifier
          .fillMaxWidth()
          .padding(start = 16.dp, end = 16.dp, bottom = 32.dp),
        shape = RoundedCornerShape(50)
      ) {
        Text(
          text = stringResource(R.string.leaderboard_play),
          style = MaterialTheme.typography.titleLarge,
          modifier = Modifier.padding(top = 8.dp, bottom = 8.dp),
          fontWeight = FontWeight.Bold
        )
      }
    }
  ) { innerPadding -&gt;
    LeaderboardContent(
      modifier = Modifier.padding(innerPadding),
      leaderboard = leaderboard.value
    )
  }
}
</code></pre>
<h2 is-upgraded>State Observation and Skeleton</h2>
<p>Start by looking at ``LeaderboardScreen. The very first thing we do is connect to our data source:</p>
<pre><code language="language-kotlin" class="language-kotlin">val leaderboard = leaderboardViewModel.leaderboard.collectAsState()
</code></pre>
<p>We act as a consumer of the <code>leaderboardViewModel</code>. By using <code>.collectAsState()</code>, we convert the ViewModel&#39;s data flow into a Compose State. This means whenever the ViewModel updates (e.g., data finishes loading), our UI will automatically recompose to reflect the changes.</p>
<p>We use the <code>Scaffold</code> again here, but with a twist:</p>
<ul>
<li><code>topBar</code>: Standard title bar.</li>
<li><code>bottomBar</code>: This the &#34;Play Again&#34; button, where the user can return to <code>IntroScreen</code>.</li>
</ul>
<p>Why the button is here? By putting the button in the bottomBar, it stays pinned to the bottom of the screen. If the list of users is long, the list will scroll behind the button, but the button itself will always be accessible.</p>
<h2 is-upgraded>Handling UI States</h2>
<p>Inside <code>LeaderboardContent</code>, we don&#39;t just show a list immediately. We have to decide what to show based on the current state of the data.</p>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
private fun LeaderboardContent(
  modifier: Modifier,
  leaderboard: UiState
) {
  Column(
    modifier = modifier
      .fillMaxSize()
      .padding(16.dp),
    horizontalAlignment = Alignment.CenterHorizontally
  ) {

    when (leaderboard) {
      is UiState.Initial,
      is UiState.Loading -&gt; LeaderboardLoading()
      is UiState.Success -&gt; LeaderboardSuccess(leaderboard.users)
      is UiState.Error -&gt; LeaderboardError()
    }
  }
}
</code></pre>
<p>This <code>when</code> is responsible to show the correct screen, depending on the current state of the leaderboard request:</p>
<ul>
<li><code>Initial</code> or <code>Loading</code>: Shows a simple LinearProgressIndicator.</li>
<li><code>Error</code>: Shows a friendly error message if the network request fails.</li>
<li><code>Success</code>: Renders the list of users.</li>
</ul>
<pre><code language="language-kotlin" class="language-kotlin">@Composable
private fun LeaderboardLoading() {
  LinearProgressIndicator(
    modifier = Modifier.fillMaxWidth()
  )
}

@Composable
private fun LeaderboardSuccess(
  users: List&lt;User&gt;
) {
  LazyColumn {
    itemsIndexed(users) { index, user -&gt;
      LeaderboardUser(&#34;${index + 1}&#34;, user.username, user.score)

      Spacer(modifier = Modifier.height(16.dp))
    }
  }
}

@Composable
private fun LeaderboardError() {
  Column(
    modifier = Modifier.fillMaxSize(),
    verticalArrangement = Arrangement.Center
  ) {
    Text(
      text = stringResource(R.string.leaderboard_error),
      style = MaterialTheme.typography.titleLarge
    )
  }
}

@Composable
private fun LeaderboardUser(
  id: String,
  username: String,
  points: Long
) {
  Row(
    modifier = Modifier
      .fillMaxWidth()
      .clip(RoundedCornerShape(25))
      .background(MaterialTheme.colorScheme.secondary)
      .border(2.dp, MaterialTheme.colorScheme.secondary, RoundedCornerShape(25))
      .padding(start = 16.dp, end = 16.dp, top = 8.dp, bottom = 8.dp),
    verticalAlignment = Alignment.CenterVertically
  ) {

    Text(
      text = id,
      style = MaterialTheme.typography.titleLarge
    )

    Spacer(modifier = Modifier.width(16.dp))

    Text(
      text = username,
      style = MaterialTheme.typography.titleLarge
    )

    Row(
      modifier = Modifier
        .fillMaxWidth()
        .padding(top = 16.dp, bottom = 16.dp),
      horizontalArrangement = Arrangement.End
    ) {
      Text(
        text = stringResource(R.string.leaderboard_points, points),
        style = MaterialTheme.typography.titleLarge
      )
    }
  }
}
</code></pre>
<p>The <code>LeaderboardSuccess</code> function simply uses a <code>LazyColumn</code> (a vertically scrolling list) to display a <code>LeaderboardUser</code> row for each user in the list.</p>
<p>Finally, the last update that you need to do is to return, once again, to <code>MainNavigation.kt</code> and in the <code>entry<Leaderboard></code> add:</p>
<pre><code language="language-kotlin" class="language-kotlin">leaderboardViewModel.fetchLeaderboard()

LeaderboardScreen(
  leaderboardViewModel = leaderboardViewModel,
  navigateToHome = {
    backStack.remove(Leaderboard)
    backStack.remove(Quiz)
  }
)
</code></pre>
<p>Congratulations! All the updates were made! Compile, run the app and... have fun! </p>


      </google-codelab-step>
    
      <google-codelab-step label="Congratulations!" duration="1">
        <p>You&#39;ve successfully built a complete AI-powered Android application!</p>
<p>You learned how to:</p>
<ul>
<li>Use the Gemini API with system instructions and <strong>JSON mode</strong> to generate structured data.</li>
<li>Integrate the Firebase <strong>AI Logic</strong> and <strong>Firestore</strong> SDKs into an Android app.</li>
<li>Save and retrieve real-time data from <strong>Firestore</strong>.</li>
<li>Structure a modern app using <strong>Jetpack Compose</strong>, <strong>ViewModels</strong>, and a <strong>UiState</strong> pattern.</li>
<li>You can expand this project by adding user authentication, storing quizzes, or using more of the Gemini API&#39;s capabilities.</li>
</ul>
<h2 is-upgraded>Further Reading</h2>
<ul>
<li><a href="https://firebase.google.com/docs/vertex-ai" target="_blank">Firebase AI Logic Documentation</a></li>
<li><a href="https://firebase.google.com/docs/firestore" target="_blank">Cloud Firestore Documentation</a></li>
<li><a href="https://developer.android.com/jetpack/compose/navigation" target="_blank">Jetpack Compose Navigation</a></li>
</ul>


      </google-codelab-step>
    
  </google-codelab>

  <script src="https://storage.googleapis.com/claat-public/native-shim.js"></script>
  <script src="https://storage.googleapis.com/claat-public/custom-elements.min.js"></script>
  <script src="https://storage.googleapis.com/claat-public/prettify.js"></script>
  <script src="https://storage.googleapis.com/claat-public/codelab-elements.js"></script>
  <script src="//support.google.com/inapp/api.js"></script>

</body>
</html>
